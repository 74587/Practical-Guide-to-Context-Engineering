# ä¸€ã€ä»€ä¹ˆæ˜¯æœç´¢ä»£ç†
åœ¨èŠæœç´¢ä»£ç†ä¹‹å‰ï¼Œå°±éœ€è¦å…ˆææ¸…æ¥šä»£ç†æ˜¯ä»€ä¹ˆï¼Œç®€å•ç†è§£å¯ä»¥æ˜¯ï¼š**LLM åœ¨è‡ªä¸»å¾ªç¯ä¸­ä½¿ç”¨å·¥å…·**

ğŸŒŸ é‚£ä¹ˆæœç´¢ä»£ç†çš„ç®€å•å®šä¹‰ï¼š**LLM ä½¿ç”¨å„ç§æœç´¢æˆ–æ£€ç´¢å·¥å…·ï¼ŒåŠ¨æ€åœ°ï¼ŒæŒ‰éœ€åœ°è·å–ç›¸å…³ä¸Šä¸‹æ–‡**


æˆ‘åœ¨æµ‹è¯•å„ç§æ¨¡å‹å¯¹äºæ£€ç´¢å·¥å…·çš„è°ƒç”¨çš„æ—¶å€™ï¼Œå‘ç°æ¨¡å‹èƒ½åŠ›å·®å¼‚å¯¼è‡´çš„æœç´¢ç»“æœä¸åŒï¼Œä¼˜ç§€çš„æ¨¡å‹çš„æœç´¢è·¯å¾„è§„åˆ’çš„æ›´åŠ åˆç†ï¼Œå¹¶ä¸”æœç´¢çš„æ–¹å‘éå¸¸å‡†ç¡®ï¼Œè€Œèƒ½åŠ›è¾ƒå·®çš„æ¨¡å‹ï¼Œæ–¹å‘é£˜å¿½ä¸å®šï¼Œç»“æœä¹Ÿå¾ˆä¸€èˆ¬

> åœ¨æ–‡ç« çš„æœ€åæˆ‘ä¼šé™„ä¸Šæµ‹è¯•æ—¥å¿—ï¼š[deepseek-èœè°± share.log](https://github.com/WakeUp-Jin/Practical-Guide-to-Context-Engineering/blob/main/docs/%E6%90%9C%E7%B4%A2%E4%BB%A3%E7%90%86/deepseek-%E8%8F%9C%E8%B0%B1%20share.log)
>

æ‰€ä»¥æˆ‘å‘ç°å½±å“æœç´¢ä»£ç†æˆåŠŸçš„å› ç´ ä¹‹ä¸€æ˜¯ï¼šæ›´æ™ºèƒ½çš„æ¨¡å‹ï¼Œå¯ä»¥ä½¿æœç´¢ä»£ç†è‡ªä¸»åº”å¯¹å¤æ‚é—®é¢˜å¹¶ä»é”™è¯¯ä¸­æ¢å¤

# äºŒã€æœç´¢ä»£ç†å’Œ RAG çš„åŒºåˆ«
Excaildraw æ–‡ä»¶ï¼š[https://gcntfv628ebr.feishu.cn/file/OoMPbYlVKoTxNmxZGhZcNt2znWe](https://gcntfv628ebr.feishu.cn/file/OoMPbYlVKoTxNmxZGhZcNt2znWe)

![æœç´¢ä»£ç†å’Œ RAG çš„åŒºåˆ«](./image/image%20(33).png)

æœç´¢ä»£ç†å’Œ RAG çš„æœ€ä¸»è¦çš„åŒºåˆ«åœ¨äºå·¥ä½œæ‰§è¡Œæµç¨‹ï¼š

+ RAG æ˜¯é¢„æ¨ç†æ£€ç´¢ï¼šç³»ç»Ÿé¢„å…ˆä»å‘é‡æ•°æ®åº“æ£€ç´¢å‡ºæ¥ç»“æœä¹‹åè¾“å…¥ç»™ LLMï¼Œè¿™ä¸ªæ—¶å€™ **LLM æ˜¯è¢«åŠ¨çš„æ¥å—**
+ æœç´¢ä»£ç†æ˜¯å³æ—¶æ£€ç´¢ï¼š**LLM æ˜¯ä¸»åŠ¨å†³ç­–è€…**ï¼Œç”± LLM æ¥å†³å®šæœç´¢ä»€ä¹ˆï¼Œæ€ä¹ˆæœç´¢ï¼Œå¹¶ä¸”å¯ä»¥æ ¹æ®ä¸­é—´ç»“æœæ¥ä¸»åŠ¨çš„è°ƒæ•´æœç´¢è·¯å¾„



æœç´¢ä»£ç†å’Œ RAG è¿˜æœ‰ä¸€ä¸ªåœ¨**ä¼˜åŒ–è¡Œä¸ºæ–¹å¼çš„åŒºåˆ«ï¼š**

<font style="color:rgb(15, 17, 21);">æœç´¢ä»£ç†ä¸­æœ‰ä¸€ç§å·¥å…·æ˜¯ </font>`glob`<font style="color:rgb(15, 17, 21);">ï¼Œè¿™ä¸ªå·¥å…·æ˜¯ç”¨æ¥æœç´¢å’ŒåŒ¹é…æ–‡ä»¶åçš„ï¼Œè¿™ä¸ªæ—¶å€™æ–‡ä»¶åä¹Ÿå¯ä»¥æˆä¸ºæœ‰æ•ˆæœç´¢å› ç´ ï¼Œå½“ä¸€ä¸ªä»£ç åº“ä¸­çš„æ–‡ä»¶ç»“æ„éå¸¸æ¸…æ™°ï¼Œå¹¶ä¸”æ–‡ä»¶å‘½ååˆç†ï¼Œåœ¨è¿™ç§å·¥ä½œç©ºé—´ä¸‹æœç´¢ä»£ç†ä¼šéå¸¸æœ‰æ•ˆï¼Œæœç´¢ä»£ç†çš„å½±å“å› ç´ å¦‚ä¸‹ï¼š</font>

+ æ–‡ä»¶å¤¹çš„ç»“æ„ï¼š ä¾‹å¦‚ï¼š`tests/test_agent.ts` è¿™ä¸ªå°±è¡¨ç¤ºæµ‹è¯•æ¨¡å—ä¸­çš„æµ‹è¯• agent åŠŸèƒ½çš„æ–‡ä»¶çš„éšæ€§å«ä¹‰
+ å‘½åçº¦å®šï¼šä¾‹å¦‚ï¼š`*.config.js` è¡¨ç¤ºé…ç½®æ–‡ä»¶ ã€`README.md` è¡¨ç¤ºæ–‡æ¡£è¯´æ˜
+ æ–‡ä»¶å¤§å°ï¼šå¯ä»¥éšå«å¤æ‚æ€§çš„èƒŒæ™¯ä¿¡æ¯
+ æ—¶é—´æˆ³ï¼šå¯ä»¥è¡¨ç¤ºæ–‡ä»¶æ˜¯æœ€è¿‘ä¿®æ”¹çš„ï¼Œéšå«è¯¥æ–‡ä»¶ç›¸å…³æ€§æ¯”è¾ƒå¼º(å› ä¸ºè¿™ä¸ªæ–‡ä»¶æ˜¯æœ€è¿‘ä¿®æ”¹çš„ï¼Œé‚£ç”¨æˆ·è¾“å…¥çš„é—®é¢˜å¾ˆå¤§æ¦‚ç‡æ˜¯å› ä¸ºä»–åˆšåˆšä¿®æ”¹è¿™ä¸ªæ–‡ä»¶äº§ç”Ÿçš„ï¼Œæˆ‘ä»¬å¯ä»¥ä»”ç»†æƒ³æƒ³è‡ªå·±ä½¿ç”¨ ClaudeCode æˆ–è€… Cursor çš„ Agent æ¨¡å¼çš„æ—¶å€™æ˜¯ä¸æ˜¯è¿™æ ·çš„å‘¢ï¼‰

åœ¨è¿™ç§æ„å»ºæ–¹å¼ä¸‹ï¼Œä»£ç†å¯ä»¥é€å±‚æ„å»ºç†è§£ï¼Œä»…åœ¨å·¥ä½œè®°å¿†ä¸­ä¿ç•™å¿…è¦ä¿¡æ¯ï¼Œ**è¿™ç§è‡ªæˆ‘ç®¡ç†çš„ä¸Šä¸‹æ–‡çª—å£ä½¿ä»£ç†ä¸“æ³¨äºç›¸å…³å­é›†ï¼Œè€Œä¸æ˜¯è¢«å¤§é‡ä½†å¯èƒ½æ— å…³çš„ä¿¡æ¯æ·¹æ²¡ã€‚**

<font style="color:rgb(15, 17, 21);">è€Œå¯¹äº RAG æ¥è¯´ï¼Œåªèƒ½é‡æ–°æ„å»ºåµŒå…¥æ–‡æ¡£å—äº†ï¼Œè€Œä¸æ˜¯åƒæœç´¢ä»£ç†è¿™æ ·éšå¿ƒæ‰€æ¬²çš„åŠ¨æ€æ›´æ¢ä¸€ä¸‹æ–‡ä»¶åå°±å¯ä»¥ï¼Œè¿™ä¹Ÿæ˜¯ä¸€ä¸ªå…³é”®åŒºåˆ«</font>**<font style="color:rgb(15, 17, 21);">æœç´¢ä»£ç†çš„ç»´æŠ¤æˆæœ¬æ¯”è¾ƒä½ï¼Œå¼€å‘èµ·æ¥æ¯”è¾ƒå¿«</font>**

**<font style="color:rgb(15, 17, 21);"></font>**

<font style="color:rgb(15, 17, 21);">å½“ç„¶ï¼Œäº‹ç‰©æ€»æ˜¯ç›¸å¯¹çš„ï¼ŒRAG è¿˜æ˜¯æœ‰ä¼˜ç§€çš„åœ°æ–¹çš„</font>

+ åœ¨å¤§é‡æ•°æ®æ—¶ï¼ŒRAG çš„æ£€ç´¢ä¼šæ¯”æœç´¢ä»£ç†å¿«å¾ˆå¤š
+ RAG çš„å¼€å‘æ„å»ºç­–ç•¥æ˜¯å¹³ç¨³çš„ï¼Œæœ‰æˆç†Ÿçš„æ„å»ºæœç´¢æ–¹æ¡ˆï¼šåˆ†å‰ç´¢å¼•ã€çˆ¶æ–‡æ¡£ç´¢å¼•ç­‰ï¼Œä½†æ˜¯æœç´¢ä»£ç†è¦æœ‰æ•ˆçš„è¯ï¼Œéœ€è¦æœ‰æ·±æ€ç†Ÿè™‘çš„å·¥ç¨‹å®è·µï¼Œè¦æœ‰æˆç†Ÿçš„æŒ‡å¯¼å¼€å‘æ–¹æ¡ˆï¼Œä¸å¦‚æœç´¢ä»£ç†ä¼šå¾ˆå®¹æ˜“è¿›å…¥æ­»å¾ªç¯å’Œæ— æ•ˆæ£€ç´¢æ¥æµªè´¹ä¸Šä¸‹æ–‡ï¼Œåœ¨è¿™ä¸ªæ–¹å‘ä¸Šï¼Œæœç´¢ä»£ç†çš„å¼€å‘éš¾åº¦æ¯” RAG å¤§å¤šäº†

**<font style="color:rgb(15, 17, 21);"></font>**

<font style="color:rgb(15, 17, 21);">é‚£æˆ‘ä»¬æ¥æ€»ç»“ä¸€ä¸‹ RAG å’Œæœç´¢ä»£ç†çš„åŒºåˆ«ç‚¹</font>

1. **å·¥ä½œæ‰§è¡Œæµç¨‹çš„åŒºåˆ«**ï¼ŒRAG æ˜¯é¢„æ¨ç†æ£€ç´¢ï¼Œæœç´¢ä»£ç†æ˜¯å³æ—¶æ£€ç´¢
2. **ä¼˜åŒ–è¡Œä¸ºæ–¹å¼çš„åŒºåˆ«**ï¼Œæœç´¢ä»£ç†çš„ä¼˜åŒ–æ–¹å‘æ›´å¤šï¼Œç­–ç•¥æ˜¯å¯ä»¥åŠ¨æ€è°ƒæ•´çš„ï¼ŒRAG éœ€è¦é‡æ–°æ„å»ºæ–‡æ¡£å—
3. **å¼€å‘å’Œç»´æŠ¤æˆæœ¬çš„åŒºåˆ«**ï¼šæœç´¢ä»£ç†çš„ç»´æŠ¤æˆæœ¬æ¯”è¾ƒä½ï¼Œæ–‡ä»¶ç³»ç»Ÿå·¥å…·å³æ—¶å¼€å‘ï¼Œä¸éœ€è¦åƒ RAG é‚£æ ·æ•´ç†æ–‡æ¡£å—ï¼Œç„¶åæ„å»ºå‘é‡æ•°æ®åº“ç­‰ï¼Œå¹¶ä¸”æœç´¢ä»£ç†è°ƒæ•´å’Œç»´æŠ¤æ¯”è¾ƒå®¹æ˜“
4. **å¤§é‡æ•°æ®çš„æ£€ç´¢é€Ÿåº¦åŒºåˆ«**ï¼šåœ¨å¤§é‡æ•°æ®çš„å‰æä¸‹ï¼ŒRAG æ£€ç´¢é€Ÿåº¦å›æ¯”æœç´¢ä»£ç†å¿«å¾ˆå¤š
5. **æœ‰æ•ˆæœç´¢ä»£ç†å¼€å‘éš¾åº¦å¤§**ï¼šè¦æƒ³æœç´¢ä»£ç†åœ¨å®é™…çš„åœºæ™¯ä¸­æœ‰æ•ˆï¼Œéœ€è¦æœ‰åˆé€‚çš„ç­–ç•¥æŒ‡å¯¼

# ä¸‰ã€æœç´¢ä»£ç†çš„åº”ç”¨åœºæ™¯
1ã€ **å¯¹äºä¸Šä¸‹æ–‡ä¿¡æ¯å¯†åº¦æœ‰è¾ƒé«˜çš„è¦æ±‚**ï¼šä¾‹å¦‚ç¼–ç¨‹å¼€å‘é¢†åŸŸï¼Œå¼€å‘è€…ä½¿ç”¨ä»£ç æ¥å®ç°è‡ªå·±ä¸¥å¯†çš„ä¸šåŠ¡é€»è¾‘ï¼Œè¿™ç§åœºæ™¯ä¸‹ä½¿ç”¨ä»£ç†æœç´¢ä¼šéå¸¸åˆé€‚

å€˜è‹¥æˆ‘ä»¬é‡‡ç”¨ RAG çš„æ–¹å¼æ¥æ£€ç´¢ï¼Œæˆ‘ä»¬éœ€è¦å¯¹ä»£ç åº“è¿›è¡Œæ–‡æ¡£å—çš„åˆ†å‰²ï¼Œå°±ä¸èƒ½åƒæ–‡æœ¬é‚£æ ·ç®€å•çš„æŒ‰ç…§è¡Œæ•°æ¥åˆ†å‰²äº†ï¼Œå› ä¸ºä»£ç ä¸Šä¸‹æ–‡ä¹‹é—´æœ‰å¾ˆå¼ºçš„é€»è¾‘ä¾èµ–ï¼Œå¦‚æœæ–‡æ¡£å—ä¸­å°‘ä¸€è¡Œ if åˆ¤æ–­ï¼Œè¡¨è¾¾çš„æ„æ€å°±æ˜¯å¤©å·®åœ°åˆ«äº†ï¼Œæ¯”è¾ƒåˆé€‚çš„çš„æ–¹æ³•æ˜¯ç»“åˆè¯­æ³•æ ‘å’Œä»£ç ä¾èµ–å…³è”æ¥è¿›è¡Œåˆ†å‰²ï¼Œ

æ‰€ä»¥è¿™ç§æƒ…å†µä¸‹ï¼Œ<font style="color:rgb(15, 17, 21);">ä¸ä»…å­˜å…¥å‘é‡æ•°æ®åº“çš„è¿‡ç¨‹æ›´éº»çƒ¦ï¼Œæ£€ç´¢æ—¶ä¹Ÿå› ä¸ºå†…éƒ¨æœºåˆ¶ä¸é€æ˜ï¼Œå¯¼è‡´å¼€å‘è€…å¾ˆéš¾çœ‹æ¸…æ£€ç´¢çš„å…¨è²Œï¼Œè°ƒè¯•èµ·æ¥ä¹Ÿæ›´å›°éš¾ã€‚</font>

<font style="color:rgb(15, 17, 21);"></font>

<font style="color:rgb(15, 17, 21);">2ã€</font>**<font style="color:rgb(15, 17, 21);">åŠ¨æ€ä¸Šä¸‹æ–‡ä¸å¤š</font>**<font style="color:rgb(15, 17, 21);">ï¼šè¦åŠ¨æ€ä¼ å…¥ç»™ LLM çš„åŠ¨æ€å¤–éƒ¨æ•°æ®ä¸å¤šçš„æ—¶å€™ï¼Œæœç´¢ä»£ç†å¾ˆé€‚ç”¨ï¼Œä¾‹å¦‚ï¼šä¸­å°å‹ä»£ç åº“ã€ä¸€äº›å…¬å¸å†…éƒ¨å®¢æœæ‰‹å†Œè¿™ç§ç›¸å¯¹å›ºå®šçš„æ•°æ®</font>

<font style="color:rgb(15, 17, 21);">æˆ‘éå¸¸æ¨èå¼€å‘è€…åœ¨æ„å»ºå¤§æ¨¡å‹åº”ç”¨åˆæœŸçš„æ—¶å€™ï¼Œå®Œå…¨å¯ä»¥ä¼˜å…ˆè€ƒè™‘ä½¿ç”¨æœç´¢ä»£ç†æ¥å®ç°å¤–éƒ¨æ•°æ®çš„å¼•å…¥ï¼Œåœ¨åº”ç”¨æ„å»ºåˆæœŸçš„æ—¶å€™ï¼Œéµå¾ªç€å¿«é€Ÿè¿­ä»£çš„åŸåˆ™ï¼Œæœç´¢ä»£ç†çš„å¼€å‘éš¾åº¦å’Œå¼€å‘æ•ˆç‡ç›¸æ¯”å¤æ‚çš„ RAG æ˜¯æœ‰ä¼˜åŠ¿çš„</font>

<font style="color:rgb(15, 17, 21);"></font>

<font style="color:rgb(15, 17, 21);">3ã€</font>**<font style="color:rgb(15, 17, 21);">åå‘ç®€å•æœ‰æ•ˆåŸåˆ™æ„å»º Agent</font>**<font style="color:rgb(15, 17, 21);">ï¼šå¤§æ¨¡å‹åº”ç”¨å¼€å‘è¿™ä¸ªé¢†åŸŸæ˜¯åœ¨å¿«é€Ÿå‘å±•çš„ï¼Œè€Œä¸”å¤§éƒ¨åˆ†éƒ½æ˜¯å‘ç€â€œLLM è¶Šæ¥è¶Šæ™ºèƒ½â€è¿™ä¸ªæ–¹å‘å‰è¡Œï¼Œæ„å»ºç®€å•çš„æ¨¡å—å’Œåº”ç”¨æ˜¯æœ€åˆé€‚çš„ï¼Œæ–¹ä¾¿åº”ç”¨å’Œæ¨¡å—è¿›è¡Œè¿­ä»£ï¼Œåƒæ¸è¿›å¼æ„å»ºæœ‰æ•ˆåº”ç”¨çš„åŸåˆ™ä¸€æ ·</font>



# å››ã€å…·ä½“å®ç°
Excalidraw æ–‡ä»¶ï¼š[https://gcntfv628ebr.feishu.cn/file/OoMPbYlVKoTxNmxZGhZcNt2znWe](https://gcntfv628ebr.feishu.cn/file/OoMPbYlVKoTxNmxZGhZcNt2znWe)

![å…·ä½“å®ç°](./image/image%20(34).png)

æˆ‘æ˜¯ä½¿ç”¨ Ts æ¥å®ç°çš„ï¼Œæˆ‘æ¯”è¾ƒç†Ÿæ‚‰è¿™ä¸ªè¯­è¨€ï¼Œæˆ‘çš„å®ç°æ¯”è¾ƒç®€å•ï¼Œæ²¡æœ‰åšè¿‡å¤šçš„å…¼å®¹ï¼Œåªä¿è¯è‡ªå·±æœ¬åœ°è¿è¡ŒæˆåŠŸï¼Œåœ¨å®ç°çš„è¿‡ç¨‹ä¸­æˆ‘å‘ç°ä¸€äº›å¤æ‚çš„åœ°æ–¹ï¼š

+ ä¸€ä¸ªæˆç†Ÿçš„æ‰§è¡Œå·¥å…·éœ€è¦å…¼å®¹å¤šç§ç³»ç»Ÿçš„ç‰ˆæœ¬ï¼Œè¿™ä¸ªæ—¶å€™æ˜¯æ¯”è¾ƒå¤æ‚çš„
+ å·¥å…·çš„æè¿°å’Œåç§°è¦å®šä¹‰çš„åˆç†ï¼Œè¡¨è¾¾çš„æ¸…æ™°ï¼Œä¸ç„¶æ¨¡å‹ä¼šæ··ä¹±è°ƒç”¨

## 4.1ã€å·¥å…·å®ç°
### 4.1.1ã€GrepTool å·¥å…·å®ç°
å®ç° GrepTool å·¥å…·å¯¹è±¡æ—¶ï¼Œéœ€è¦ä¸€äº›å·¥å…·çš„å‚æ•°å®šä¹‰ï¼Œæ¯”è¾ƒé‡è¦çš„æ˜¯å·¥å…·å‚æ•°

+ patternï¼šæœç´¢çš„æ­£åˆ™è¡¨è¾¾å¼
+ pathï¼šæœç´¢è·¯å¾„ï¼ˆç›®å½•ï¼‰
+ includeï¼šæ–‡ä»¶æ¨¡å¼è¿‡æ»¤

```typescript
import { InternalTool, InternalToolContext } from '../types.js';
import { ripGrep } from '../../utils/ripgrep.js';

export const TOOL_NAME_FOR_PROMPT = 'GrepTool';
export const DESCRIPTION = `
- é€‚ç”¨äºä»»ä½•ä»£ç åº“å¤§å°çš„å¿«é€Ÿå†…å®¹æœç´¢å·¥å…·
- ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æœç´¢æ–‡ä»¶å†…å®¹
- æ”¯æŒå®Œæ•´çš„æ­£åˆ™è¡¨è¾¾å¼è¯­æ³•ï¼ˆä¾‹å¦‚ "log.*Error"ã€"function\\s+\\w+" ç­‰ï¼‰
- ä½¿ç”¨ include å‚æ•°æŒ‰æ¨¡å¼è¿‡æ»¤æ–‡ä»¶ï¼ˆä¾‹å¦‚ "*.js"ã€"*.{ts,tsx}"ï¼‰
- è¿”å›æŒ‰ä¿®æ”¹æ—¶é—´æ’åºçš„åŒ¹é…æ–‡ä»¶è·¯å¾„
- å½“ä½ éœ€è¦æŸ¥æ‰¾åŒ…å«ç‰¹å®šæ¨¡å¼çš„æ–‡ä»¶æ—¶ä½¿ç”¨æ­¤å·¥å…·
- å½“ä½ è¿›è¡Œå¯èƒ½éœ€è¦å¤šè½® glob å’Œ grep çš„å¼€æ”¾å¼æœç´¢æ—¶ï¼Œè¯·æ”¹ç”¨ Agent å·¥å…·
`;


/**
 * GrepTool å‚æ•°å®šä¹‰
 */
export interface GrepToolArgs {
  /** æœç´¢çš„æ­£åˆ™è¡¨è¾¾å¼æ¨¡å¼ */
  pattern: string;
  /** æœç´¢è·¯å¾„ï¼ˆç›®å½•ï¼‰ */
  path?: string;
  /** æ–‡ä»¶æ¨¡å¼è¿‡æ»¤ */
  include?: string;
}

/**
 * GrepTool è¿”å›ç»“æœ
 */
export interface GrepToolResult {
  /** åŒ¹é…çš„æ–‡ä»¶è·¯å¾„ */
  matches: string[];
  /** åŒ¹é…æ€»æ•° */
  count: number;
}

/**
 * GrepTool å¤„ç†å‡½æ•°
 */
const grepToolHandler = async (
  args: GrepToolArgs,
  context?: InternalToolContext
): Promise<GrepToolResult> => {
  const { pattern, path = context?.cwd || process.cwd(), include } = args;

  // æ„å»º ripgrep å‚æ•°
  const rgArgs: string[] = [];

  // åªè¿”å›æ–‡ä»¶è·¯å¾„
  rgArgs.push('-l'); // --files-with-matches

  // æ–‡ä»¶æ¨¡å¼è¿‡æ»¤
  if (include) {
    rgArgs.push('--glob', include);
  }

  // æœç´¢æ¨¡å¼
  rgArgs.push(pattern);

  // æ‰§è¡Œæœç´¢
  const abortSignal = context?.abortSignal || new AbortController().signal;
  const results = (await ripGrep(rgArgs, path, abortSignal)) as string[];

  return {
    matches: results,
    count: results.length,
  };
};

/**
 * GrepTool å·¥å…·å®šä¹‰
 */
export const GrepTool: InternalTool<GrepToolArgs, GrepToolResult> = {
  name: 'grep_search',
  category: 'search',
  internal: true,
  description: DESCRIPTION,
  version: '1.0.0',
  parameters: {
    type: 'object',
    properties: {
      pattern: {
        type: 'string',
        description:
          'The regular expression pattern to search for in file contents',
      },
      path: {
        type: 'string',
        description:
          'The directory to search in. Defaults to the current working directory.',
      },
      include: {
        type: 'string',
        description:
          'File pattern to include in the search (e.g. "*.js", "*.{ts,tsx}")',
      },
    },
    required: ['pattern'],
  },
  handler: grepToolHandler,
};

```



åœ¨å®ç°è¿™ä¸ª grepTool å·¥å…·å‡½æ•°çš„æ—¶å€™ï¼Œä½¿ç”¨çš„æ˜¯ ripgrep å‘½ä»¤ï¼Œè¿™ä¸ªå‘½ä»¤æ‰§è¡Œçš„é€Ÿåº¦éå¸¸å¿«ï¼Œæ¯”ä¸€èˆ¬çš„æœç´¢å‘½ä»¤è¦å¿«å¾ˆå¤šï¼Œåœ¨æ„å»ºè¿™ä¸ªå‘½ä»¤æ‰§è¡Œçš„å‡½æ•°éœ€è¦æ³¨æ„ä¸¤ç‚¹ï¼š

1. Mac ç³»ç»Ÿéœ€è¦æ„å»ºæ‰§è¡Œæ–‡ä»¶çš„ç­¾å
2. å‘½ä»¤æ‰§è¡Œçš„æ—¶å€™éœ€è¦åˆ¤æ–­ï¼Œå¦‚æœæœ¬åœ°ç”µè„‘æ²¡æœ‰ rg è¿™ä¸ªå‘½ä»¤ï¼Œå°±éœ€è¦ä½¿ç”¨ vendor é‡Œé¢çš„äºŒè¿›åˆ¶æ–‡ä»¶æ¥æ‰§è¡Œäº†

> ä½¿ç”¨å‘½ä»¤ ripgrepï¼š[https://github.com/BurntSushi/ripgrep](https://github.com/BurntSushi/ripgrep)
>

```typescript
import { fileURLToPath } from 'url';
import path from 'path';
import { findActualExecutable } from 'spawn-rx';
import { execFile } from 'child_process';
import { execFileNoThrow } from './execFileNoThrow.js';
import { config } from '../config/env.js';

const __filename = fileURLToPath(import.meta.url);
let __dirname = path.dirname(__filename);

console.log(config.nodeEnv);

if (config.nodeEnv === 'development' || config.nodeEnv === 'test') {
  __dirname = path.resolve(__dirname, '..', '..');
}

function ripgrepPath() {
  //æ£€æŸ¥æœ¬åœ°æ˜¯å¦å®‰è£…äº†ripgrep
  const { cmd } = findActualExecutable('rg', []);

  if (cmd !== 'rg') {
    return cmd;
  } else {
    const rgRoot = path.resolve(__dirname, 'vendor', 'ripgrep');
    console.log(rgRoot);

    const ret = path.resolve(
      rgRoot,
      `${process.arch}-${process.platform}`,
      'rg'
    );
    console.log(ret);
    return ret;
  }
}

export async function ripGrep(
  args: string[],
  target: string,
  abortSignal: AbortSignal
) {
  //macç”µè„‘çš„ç­¾å
  await macSignature();
  const rgPath = ripgrepPath();

  return new Promise(resolve => {
    execFile(
      ripgrepPath(),
      [...args, target],
      {
        maxBuffer: 1_000_000,
        signal: abortSignal,
        timeout: 10_000,
      },
      (error, stdout) => {
        if (error) {
          if (error.code !== 1) {
            console.log(error);
          }
          resolve([]);
        } else {
          resolve(stdout.split('\n').filter(Boolean));
        }
      }
    );
  });
}

//macç”µè„‘çš„ç­¾å
let alreadSign = false;
async function macSignature() {
  if (process.platform !== 'darwin') {
    return '';
  }
  alreadSign = true;

  console.log('å¼€å§‹éªŒè¯ç­¾å...');
  const lines = (
    await execFileNoThrow(
      'codesign',
      ['-vv', '-d', ripgrepPath()],
      undefined,
      undefined,
      false
    )
  ).stdout.split('\n');
  console.log(lines);
  const needsSigned = lines.find(line => line.includes('linker-signed'));
  if (!needsSigned) {
    console.log('ä¸éœ€è¦ç­¾å');
    return;
  }

  try {
    console.log('ç”Ÿæˆripgrepç­¾å');
    const signResult = await execFileNoThrow('codesign', [
      '--sign',
      '-',
      '--force',
      '',
      '--preserve-metadata=entitlements,requirements,flags,runtime',
      ripgrepPath(),
    ]);
    if (signResult.code !== 0) {
      console.log('ç­¾åå¤±è´¥', signResult.stderr);
    }

    console.log('ç§»é™¤åº”ç”¨éš”ç¦»æ ‡è®°');
    const quarantineResult = await execFileNoThrow('xattr', [
      '-d',
      'com.apple.quarantine',
      ripgrepPath(),
    ]);
    if (quarantineResult.code !== 0) {
      console.log('ç§»é™¤åº”ç”¨éš”ç¦»æ ‡è®°å¤±è´¥', quarantineResult.stderr);
    }

    console.log('ç­¾åæˆåŠŸ');
  } catch (error) {
    console.error('ç­¾åç”Ÿæˆå¤±è´¥', error);
  }
}
```

### 4.1.2ã€GlobTool å·¥å…·å®ç°
å®ç° GlobTool å·¥å…·å¯¹è±¡çš„æ—¶å€™ï¼Œç›¸åº”çš„å·¥å…·å‚æ•°çš„å®šä¹‰ï¼š

+ patternï¼šGlob åŒ¹é…æ¨¡å¼
+ pathï¼šæœç´¢è·¯å¾„

```typescript
import { InternalTool, InternalToolContext } from '../types.js';
import { glob } from '../../utils/file.js';
export const TOOL_NAME_FOR_PROMPT = 'GlobTool';

export const DESCRIPTION = `- é€‚ç”¨äºä»»ä½•ä»£ç åº“å¤§å°çš„å¿«é€Ÿæ–‡ä»¶æ¨¡å¼åŒ¹é…å·¥å…·
- æ”¯æŒåƒ "**/*.js" æˆ– "src/**/*.ts" è¿™æ ·çš„ glob æ¨¡å¼
- è¿”å›æŒ‰ä¿®æ”¹æ—¶é—´æ’åºçš„åŒ¹é…æ–‡ä»¶è·¯å¾„
- å½“ä½ éœ€è¦é€šè¿‡åç§°æ¨¡å¼æŸ¥æ‰¾æ–‡ä»¶æ—¶ä½¿ç”¨æ­¤å·¥å…·
- å½“ä½ è¿›è¡Œå¯èƒ½éœ€è¦å¤šè½® glob å’Œ grep çš„å¼€æ”¾å¼æœç´¢æ—¶ï¼Œè¯·æ”¹ç”¨ Agent å·¥å…·
`;
/**
 * GlobTool å‚æ•°å®šä¹‰
 */
export interface GlobToolArgs {
  /** Glob åŒ¹é…æ¨¡å¼ */
  pattern: string;
  /** æœç´¢è·¯å¾„ï¼ˆç›®å½•ï¼‰ */
  path?: string;
}

/**
 * GlobTool è¿”å›ç»“æœ
 */
export interface GlobToolResult {
  /** åŒ¹é…çš„æ–‡ä»¶è·¯å¾„ */
  files: string[];
  /** æ˜¯å¦è¢«æˆªæ–­ */
  truncated: boolean;
  /** åŒ¹é…æ€»æ•° */
  count: number;
}

/**
 * GlobTool å¤„ç†å‡½æ•°
 */
const globToolHandler = async (
  args: GlobToolArgs,
  context?: InternalToolContext
): Promise<GlobToolResult> => {
  const { pattern, path = context?.cwd || process.cwd() } = args;

  // æ‰§è¡Œ glob æœç´¢
  const abortSignal = context?.abortSignal || new AbortController().signal;
  const result = await glob(
    pattern,
    path,
    { limit: 100, offset: 0 },
    abortSignal
  );

  return {
    files: result.files,
    truncated: result.truncated,
    count: result.files.length,
  };
};

/**
 * GlobTool å·¥å…·å®šä¹‰
 */
export const GlobTool: InternalTool<GlobToolArgs, GlobToolResult> = {
  name: 'glob_search',
  category: 'search',
  internal: true,
  description: DESCRIPTION,
  version: '1.0.0',
  parameters: {
    type: 'object',
    properties: {
      pattern: {
        type: 'string',
        description:
          'The glob pattern to match files (e.g., "**/*.ts", "src/**/*.{js,jsx}")',
      },
      path: {
        type: 'string',
        description:
          'The directory to search in. Defaults to the current working directory.',
      },
      offset: {
        type: 'number',
        description: 'Number of results to skip (for pagination, default: 0)',
      },
      limit: {
        type: 'number',
        description: 'Maximum number of results to return (default: 100)',
      },
    },
    required: ['pattern'],
  },
  handler: globToolHandler,
};

```



è¿™ä¸ªå‘½ä»¤çš„å®ç°ç›¸å¯¹æ¥è¯´æ¯”è¾ƒç®€å•ï¼Œä½¿ç”¨ glob æ¡†æ¶å°±å¯ä»¥æå®š

```typescript
import { glob as globLib } from 'glob';

//åŒ¹é…æœç´¢æ–‡ä»¶ç›®å½•ä¸‹çš„æ–‡ä»¶
export async function glob(
  filePattern: string,
  cwd: string,
  { limit, offset }: { limit: number; offset: number },
  abortSignal: AbortSignal
) {
  const paths = await globLib([filePattern], {
    cwd,
    nocase: true,
    nodir: true,
    signal: abortSignal,
    stat: true,
    withFileTypes: true,
  });

  const sortedPaths = paths.sort((a, b) => (a.mtimeMs ?? 0) - (b.mtimeMs ?? 0));
  const truncated = sortedPaths.length > offset + limit;

  return {
    files: sortedPaths
      .slice(offset, offset + limit)
      .map(path => path.fullpath()),
    truncated,
  };
}
```



### 4.1.3ã€FileReadTool å·¥å…·å®ç°
å®ç°è¿™ä¸ªæ–‡ä»¶å†…å®¹è¯»å–çš„å·¥å…·å¯¹è±¡ï¼Œå¢åŠ äº†ä¸€ä¸ªç±»ä¼¼äºåˆ†é¡µè¯»å–å†…å®¹çš„åŠŸèƒ½ï¼Œé¿å…ä¸€æ¬¡è¯»å–å¤ªå¤šï¼Œç›¸åº”çš„å·¥å…·å‚æ•°å®šä¹‰ï¼š

+ file_pathï¼šæ–‡ä»¶è·¯å¾„
+ offsetï¼šèµ·å§‹è¡Œå·
+ limitï¼šæœ€å¤§è¯»å–è¡Œæ•°

```typescript
import { InternalTool, InternalToolContext } from '../types.js';
import { readFileContent } from '../../utils/file.js';
const MAX_LINES_TO_READ = 2000;
const MAX_LINE_LENGTH = 2000;

export const DESCRIPTION = 'ä»æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿè¯»å–æ–‡ä»¶ã€‚';
export const PROMPT = `ä»æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿè¯»å–æ–‡ä»¶ã€‚file_path å‚æ•°å¿…é¡»æ˜¯ç»å¯¹è·¯å¾„ï¼Œè€Œä¸æ˜¯ç›¸å¯¹è·¯å¾„ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œå®ƒä»æ–‡ä»¶å¼€å¤´è¯»å–æœ€å¤š ${MAX_LINES_TO_READ} è¡Œã€‚ä½ å¯ä»¥é€‰æ‹©æŒ‡å®šè¡Œåç§»é‡å’Œé™åˆ¶ï¼ˆå¯¹äºé•¿æ–‡ä»¶ç‰¹åˆ«æœ‰ç”¨ï¼‰ï¼Œä½†å»ºè®®é€šè¿‡ä¸æä¾›è¿™äº›å‚æ•°æ¥è¯»å–æ•´ä¸ªæ–‡ä»¶ã€‚ä»»ä½•è¶…è¿‡ ${MAX_LINE_LENGTH} ä¸ªå­—ç¬¦çš„è¡Œå°†è¢«æˆªæ–­ã€‚å¯¹äºå›¾åƒæ–‡ä»¶ï¼Œè¯¥å·¥å…·å°†ä¸ºä½ æ˜¾ç¤ºå›¾åƒã€‚`;

/**
 * FileReadTool å‚æ•°å®šä¹‰
 */
export interface FileReadToolArgs {
  /** æ–‡ä»¶è·¯å¾„ */
  file_path: string;
  /** èµ·å§‹è¡Œå·ï¼ˆä»0å¼€å§‹ï¼‰ */
  offset?: number;
  /** æœ€å¤§è¯»å–è¡Œæ•° */
  limit?: number;
}

/**
 * FileReadTool è¿”å›ç»“æœ
 */
export interface FileReadToolResult {
  /** æ–‡ä»¶å†…å®¹ */
  content: string;
  /** è¿”å›çš„è¡Œæ•° */
  lineCount: number;
  /** æ–‡ä»¶æ€»è¡Œæ•° */
  totalLines: number;
  /** æ–‡ä»¶è·¯å¾„ */
  filePath: string;
}

/**
 * FileReadTool å¤„ç†å‡½æ•°
 */
const fileReadToolHandler = async (
  args: FileReadToolArgs,
  context?: InternalToolContext
): Promise<FileReadToolResult> => {
  const { file_path, offset = 0, limit } = args;

  // è¯»å–æ–‡ä»¶å†…å®¹
  const result = await readFileContent(file_path, offset, limit);

  return {
    content: result.content,
    lineCount: result.lineCount,
    totalLines: result.totalLines,
    filePath: file_path,
  };
};

/**
 * FileReadTool å·¥å…·å®šä¹‰
 */
export const FileReadTool: InternalTool<FileReadToolArgs, FileReadToolResult> =
  {
    name: 'read_file',
    category: 'filesystem',
    internal: true,
    description: DESCRIPTION,
    version: '1.0.0',
    parameters: {
      type: 'object',
      properties: {
        file_path: {
          type: 'string',
          description: 'The absolute or relative path to the file to read',
        },
        offset: {
          type: 'number',
          description: 'Starting line number (0-indexed, default: 0)',
        },
        limit: {
          type: 'number',
          description:
            'Maximum number of lines to read (omit to read entire file)',
        },
      },
      required: ['file_path'],
    },
    handler: fileReadToolHandler,
  };

```



è¿™ä¸ªæ–‡ä»¶å†…å®¹è¯»å–å·¥å…·ä½¿ç”¨çš„æ˜¯ Node çš„ fs æ¨¡å—ä¸­çš„æ–‡ä»¶è¯»å–å‘½ä»¤ï¼Œéœ€è¦é‡ç‚¹æ³¨æ„çš„æ˜¯æ–‡ä»¶ç¼–ç æ ¼å¼è¦è·å–ï¼Œä¸ä¸€å®šæ–‡ä»¶ç¼–ç æ ¼å¼éƒ½æ˜¯ utf-8

```typescript
//è¯»å–æ–‡ä»¶å†…å®¹
export async function readFileContent(
  filePath: string,
  offset: number = 0,
  maxLines?: number
): Promise<{ content: string; lineCount: number; totalLines: number }> {
  //TODO:è·å–æ–‡ä»¶çš„ç¼–ç æ ¼å¼ - é»˜è®¤UTF-8è¿™ä¸ªåŸæœ¬æ˜¯éœ€è¦å†™ä¸€ä¸ªæ–‡ä»¶ç¼–ç è·å–çš„å‡½æ•°
  const enc = 'utf-8';
  //è¯»å–æ–‡ä»¶å†…å®¹
  const content = await readFileSync(filePath, enc);

  //æŒ‰è¡Œåˆ‡å‰² - è·¨å¹³å°çš„å…¼å®¹è¦ä½¿ç”¨"/\r?\n/"
  const lines = content.split('\n');

  //æ•´ç†è¿”å›ç»“æœ
  const toReturn =
    maxLines !== undefined && lines.length - offset > maxLines
      ? lines.slice(offset, offset + maxLines)
      : lines.slice(offset);

  return {
    content: toReturn.join('\n'),
    lineCount: toReturn.length,
    totalLines: lines.length,
  };
}
```



### 4.1.4ã€ListDirectoryTool å·¥å…·å®ç°
è¯¥å·¥å…·æ˜¯æ–‡ä»¶ç›®å½•ç»“æ„æŸ¥è¯¢ï¼Œå·¥å…·å‡½æ•°çš„å‚æ•°åªæœ‰ä¸€ä¸ªï¼š

+ pathï¼šè¦åˆ—å‡ºç›®å½•çš„è·¯å¾„

```typescript
import { InternalTool, InternalToolContext } from '../types.js';
import {
  listDirectory,
  createFileTree,
  printTree,
} from '../../utils/listDirectory.js';

export const DESCRIPTION =
  'åˆ—å‡ºæŒ‡å®šè·¯å¾„ä¸­çš„æ–‡ä»¶å’Œç›®å½•ã€‚path å‚æ•°å¿…é¡»æ˜¯ç»å¯¹è·¯å¾„ï¼Œè€Œä¸æ˜¯ç›¸å¯¹è·¯å¾„ã€‚å¦‚æœä½ çŸ¥é“è¦æœç´¢å“ªäº›ç›®å½•ï¼Œé€šå¸¸åº”ä¼˜å…ˆä½¿ç”¨ Glob å’Œ Grep å·¥å…·ã€‚';

/**
 * ListDirectoryTool å‚æ•°å®šä¹‰
 */
export interface ListDirectoryToolArgs {
  /** è¦åˆ—å‡ºçš„ç›®å½•è·¯å¾„ */
  path?: string;
}

/**
 * ListDirectoryTool è¿”å›ç»“æœ
 */
export interface ListDirectoryToolResult {
  /** æ–‡ä»¶æ ‘æ ¼å¼è¾“å‡º */
  tree: string;
  /** æ–‡ä»¶è·¯å¾„åˆ—è¡¨ */
  files: string[];
  /** æ€»æ•° */
  count: number;
}

/**
 * ListDirectoryTool å¤„ç†å‡½æ•°
 */
const listDirectoryToolHandler = async (
  args: ListDirectoryToolArgs,
  context?: InternalToolContext
): Promise<ListDirectoryToolResult> => {
  const { path = context?.cwd || process.cwd() } = args;

  // æ‰§è¡Œç›®å½•åˆ—å‡º
  const abortSignal = context?.abortSignal || new AbortController().signal;
  const files = listDirectory(path, context?.cwd || process.cwd(), abortSignal);

  // åˆ›å»ºæ–‡ä»¶æ ‘
  const tree = createFileTree(files);
  const treeOutput = printTree(tree);

  return {
    tree: treeOutput,
    files,
    count: files.length,
  };
};

/**
 * ListDirectoryTool å·¥å…·å®šä¹‰
 */
export const ListDirectoryTool: InternalTool<
  ListDirectoryToolArgs,
  ListDirectoryToolResult
> = {
  name: 'list_directory',
  category: 'filesystem',
  internal: true,
  description: DESCRIPTION,
  version: '1.0.0',
  parameters: {
    type: 'object',
    properties: {
      path: {
        type: 'string',
        description:
          'The directory path to list. Defaults to the current working directory.',
      },
    },
    required: [],
  },
  handler: listDirectoryToolHandler,
};

```



åœ¨å®ç°è¯¥å·¥å…·å‡½æ•°çš„ä¸­ï¼Œæ²¡æœ‰ä½¿ç”¨é€’å½’å‡½æ•°å»å®ç°ï¼Œæ‹…å¿ƒæ ˆæº¢å‡ºï¼Œä½¿ç”¨çš„æ˜¯ä¸€ä¸ªå¹¿åº¦æœç´¢ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ä¸¤ä¸ªæ ¼å¼åŒ–çš„å‡½æ•°

+ å°†æœç´¢å‡ºæ¥çš„æ–‡ä»¶æ•°ç»„è½¬æ¢ä¸º Tree æ ¼å¼çš„æ•°æ®ç»“æ„
+ å°† Tree æ ¼å¼çš„æ•°æ®ç»“æ„è½¬æ¢ä¸ºç©ºæ ¼éš”å¼€çš„ç›®å½•å­—ç¬¦ä¸²

```typescript
import { readdirSync } from 'fs';
import { basename, join, relative, sep } from 'path';
import { getCwd } from './common.js';

export function listDirectory(
  initialPath: string,
  cwd: string,
  abortSignal: AbortSignal
): string[] {
  const results: string[] = [];

  const queue = [initialPath];

  while (queue.length > 0) {
    if (results.length > 500) {
      return results;
    }

    if (abortSignal.aborted) {
      return results;
    }
    const path: any = queue.shift();

    if (skip(path)) {
      continue;
    }

    if (path !== initialPath) {
      results.push(relative(cwd, path) + sep);
    }

    let children;
    try {
      children = readdirSync(path, {
        withFileTypes: true,
      });
    } catch (error) {
      console.error(error);
      continue;
    }

    for (const child of children) {
      if (child.isDirectory()) {
        queue.push(join(path, child.name) + sep);
      } else {
        const fileName = join(path, child.name);
        if (skip(fileName)) {
          continue;
        }
        results.push(relative(cwd, fileName));
        if (results.length > 500) {
          return results;
        }
      }
    }
  }

  return results;
}

function skip(path: string): boolean {
  if (path !== '.' && basename(path).startsWith('.')) {
    return true;
  }
  if (path.includes(`__pycache__${sep}`)) {
    return true;
  }
  return false;
}

/**
 * ä¸ºäº†è®©ç»“æœæ›´åŠ å¯è¯»å’ŒèŠ‚çœTokenï¼Œè¦åˆ›å»ºä¸¤ä¸ªå¯¹äºç»“æœè¿›è¡Œæ ¼å¼åŒ–çš„å‡½æ•°
 *  - createFileTree
 *  - printTree
 */

type TreeNode = {
  name: string;
  path: string;
  type: 'file' | 'directory';
  children?: TreeNode[];
};
export function createFileTree(sortedPaths) {
  const root: TreeNode[] = [];

  for (const path of sortedPaths) {
    const parts = path.split(sep);
    let currentLevel: any = root;
    let currentPath = '';

    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      if (!part) {
        continue;
      }
      currentPath = currentPath ? `${currentPath}${sep}${part}` : part;
      const isLastPart = i === parts.length - 1;

      const existingNode = currentLevel.find(node => node.name === part);

      if (existingNode) {
        currentLevel = existingNode.children || [];
      } else {
        const newNode: TreeNode = {
          name: part,
          path: currentPath,
          type: isLastPart ? 'file' : 'directory',
        };

        if (!isLastPart) {
          newNode.children = [];
        }

        currentLevel.push(newNode);
        currentLevel = newNode.children || [];
      }
    }
  }

  return root;
}

/**
 * eg.
 * - src/
 *   - index.ts
 *   - utils/
 *     - file.ts
 * @param tree
 * @param level
 * @param prefix
 * @returns
 */
export function printTree(tree: TreeNode[], level = 0, prefix = ''): string {
  let result = '';

  if (level == 0) {
    result += `- ${getCwd()}${sep}\n`;
    prefix = '  ';
  }

  for (const node of tree) {
    result += `${prefix}${'-'} ${node.name}${node.type === 'directory' ? sep : ''}\n`;

    if (node.children && node.children.length > 0) {
      result += printTree(node.children, level + 1, `${prefix}  `);
    }
  }

  return result;
}

```

## 4.2ã€å·¥å…·ç®¡ç†
æˆ‘ä»¬å®šä¹‰å¥½è¿™äº›å·¥å…·ä¹‹åï¼Œéœ€è¦å°†è¿™ä¸ªå·¥å…·æä¾›ç»™ LLMï¼Œå¹¶ä¸” LLM è¿”å›å·¥å…·æ‰§è¡Œå‘½ä»¤çš„æ—¶å€™ï¼Œéœ€è¦è°ƒç”¨ç›¸åº”å·¥å…·çš„å‡½æ•°æ‰§è¡Œï¼Œæœ€åå°†ç»“æœè¿”å›ç»™ LLMï¼Œæ‰€ä»¥è¿™é‡Œéœ€è¦åˆ›å»ºä¸€ä¸ªå·¥å…·ç®¡ç†å™¨

æˆ‘çš„å®ç°æ€è·¯ï¼š

+ æä¾›ä¸€ä¸ªæ–¹æ³•ç”¨æ¥æ³¨å†Œå·¥å…·å‡½æ•°ï¼š`registerAllTools`
+ æä¾›ä¸€ä¸ªæ–¹æ³•ç”¨æ¥è·å–æ³¨å†Œå¥½çš„å·¥å…·å‡½æ•°ï¼š`getTools`
+ æä¾›ä¸€ä¸ªå·¥å…·æ‰§è¡Œå‡½æ•°ï¼š`execute`

```typescript
import {
  InternalTool,
  InternalToolContext,
  FormattedToolDefinition,
} from './types.js';
import { GrepTool } from './GrepTool/GrepTool.js';
import { ListDirectoryTool } from './ListDirectoryTool/ListDirectoryTool.js';
import { GlobTool } from './GolbTool/GlobTool.js';
import { FileReadTool } from './FileReadTool/FileReadTool.js';

const toolsList = [GrepTool, GlobTool, ListDirectoryTool, FileReadTool];

/**
 * å·¥å…·ç®¡ç†ç±»
 * è´Ÿè´£å·¥å…·çš„æ³¨å†Œã€æŸ¥è¯¢å’Œæ‰§è¡Œ
 */
export class ToolManager {
  private tools: Map<string, InternalTool> = new Map();

  constructor() {
    // åœ¨æ„é€ å‡½æ•°ä¸­è‡ªåŠ¨æ³¨å†Œæ‰€æœ‰å·¥å…·
    this.registerAllTools();
  }

  /**
   * æ³¨å†Œæ‰€æœ‰å·¥å…·
   * æ˜¾å¼åˆ—å‡ºæ‰€æœ‰è¦æ³¨å†Œçš„å·¥å…·
   */
  private registerAllTools() {
    const tools = [...toolsList];

    tools.forEach(tool => {
      this.tools.set(tool.name, tool);
    });
  }

  /**
   * æ‰§è¡ŒæŒ‡å®šå·¥å…·
   * @param name å·¥å…·åç§°
   * @param args å·¥å…·å‚æ•°
   * @param context å¯é€‰çš„ä¸Šä¸‹æ–‡å‚æ•°ï¼ˆå¦‚ abortSignalï¼‰
   * @returns å·¥å…·æ‰§è¡Œç»“æœ
   */
  async execute<TArgs = any, TResult = any>(
    name: string,
    args: TArgs,
    context?: InternalToolContext
  ): Promise<TResult> {
    const tool = this.tools.get(name);

    if (!tool) {
      throw new Error(
        `Tool '${name}' not found. Available tools: ${this.getToolNames().join(', ')}`
      );
    }

    try {
      const result = await tool.handler(args, context);
      return result;
    } catch (error) {
      console.error(`Tool '${name}' execution failed:`, error);
      throw error;
    }
  }

  /**
   * è·å–æ‰€æœ‰å·²æ³¨å†Œçš„å·¥å…·
   * @returns å·¥å…·æ•°ç»„
   */
  getTools(): InternalTool[] {
    return Array.from(this.tools.values());
  }
}

```



åœ¨ä½¿ç”¨çš„æ—¶å€™ï¼Œå› ä¸ºä¾›åº”å•†çš„ä¸åŒï¼Œå¯¹äº api ä¸­çš„ tool å‚æ•°çš„æ ¼å¼ä¹Ÿæ˜¯ä¸ä¸€æ ·çš„ï¼Œæ‰€ä»¥è¿™ä¸ªéœ€è¦åœ¨å®šä¹‰ LLM ç±»çš„æ—¶å€™ï¼Œè‡ªå·±æä¾›ä¸€ä¸ªå·¥å…·æ ¼å¼è½¬æ¢æ–¹æ³•ï¼Œä¾‹å¦‚ Openai çš„å‚æ•°æ ¼å¼æ˜¯

```typescript
  /**
   * Format tools for OpenAI API format
   * Converts ToolSet to array of OpenAI tool definitions
   */
  private formatToolsForAPI(tools: ToolSet): OpenAITool[] {
    return Object.values(tools).map(tool => ({
      type: 'function' as const,
      function: {
        name: tool.name,
        description: tool.description || '',
        parameters: tool.parameters || {
          type: 'object' as const,
          properties: {},
        },
      },
    }));
  }
```

## 4.3ã€LLM å·¥å…·è°ƒç”¨
Excalidraw æ–‡ä»¶ï¼š[https://gcntfv628ebr.feishu.cn/file/BrjYbAJsPoAwXuxKmkWczabUnOh](https://gcntfv628ebr.feishu.cn/file/BrjYbAJsPoAwXuxKmkWczabUnOh)

![LLM å·¥å…·è°ƒç”¨](./image/image%20(35).png)

å…³äº LLM çš„è°ƒç”¨ä¸­ï¼Œæœ€æ ¸å¿ƒçš„æ€è·¯æ˜¯ï¼š**LLM å¾ªç¯æ‰§è¡Œå¹¶ä¸”åˆ¤æ–­ï¼Œå¹¶ä¸”è®¾ç½®æœ€å¤§çš„å¾ªç¯æ•°ï¼Œä¸è¦é™·å…¥æ­»å¾ªç¯**

```typescript
  async generate(
    userInput: string,
    imageData?: any,
    stream: boolean = false
  ): Promise<string> {
    try {
      // DeepSeek doesn't support images, so we ignore imageData parameter
      if (imageData) {
        console.warn(
          'DeepSeek does not support image inputs. Image data will be ignored.'
        );
      }

      // Build messages array
      const messages = this.formatMessages(userInput);

      // Get tools if available
      const tools = await this.getAllTools();
      const hasTools = tools && Object.keys(tools).length > 0;

      // Tool calling loop
      let iteration = 0;
      let finalResponse = '';

      while (iteration < this.maxIterations) {
        iteration++;
        console.log(`\n=== Iteration ${iteration}/${this.maxIterations} ===`);
        appendFileSync(
          'deepseek.log',
          `\n=== Iteration ${iteration}/${this.maxIterations} ===`
        );

        // Make API call
        const response = await this.openai.chat.completions.create({
          model: this.model,
          messages,
          stream,
          ...(hasTools && { tools: this.formatToolsForAPI(tools) }),
        });

        if (stream) {
          // Handle streaming response
          let streamContent = '';
          for await (const chunk of response) {
            const content = chunk.choices[0]?.delta?.content || '';
            streamContent += content;
            if (this.eventManager) {
              this.eventManager.emit('stream', { content });
            }
          }
          finalResponse = streamContent;
          break; // Streaming doesn't support tool calls in chunks
        }

        const message = response.choices[0]?.message;
        const finishReason = response.choices[0]?.finish_reason;

        console.log('Finish reason:', finishReason);
        if (message?.content) {
          console.log('Assistant:', message.content);
          appendFileSync('deepseek.log', `\nAssistant:${message.content}`);
        }

        // Check if model wants to call tools
        if (finishReason === 'tool_calls' && message?.tool_calls) {
          console.log(`Tool calls detected: ${message.tool_calls.length}`);
          appendFileSync(
            'deepseek.log',
            `\nTool calls detected: ${message.tool_calls.length}`
          );
          // Add assistant message with tool_calls to context
          messages.push({
            role: 'assistant',
            content: message.content || '',
            tool_calls: message.tool_calls,
          });

          // Execute each tool call
          for (const toolCall of message.tool_calls) {
            const toolName = toolCall.function.name;
            const toolArgs = JSON.parse(toolCall.function.arguments);

            console.log(`Executing tool: ${toolName}`, toolArgs);
            appendFileSync(
              'deepseek.log',
              `\nExecuting tool: ${JSON.stringify(toolName)} ${JSON.stringify(toolArgs)}`
            );
            try {
              // Execute tool using tool manager
              const toolResult = await this.toolManager?.execute(
                toolName,
                toolArgs
              );

              console.log(
                `Tool result:${JSON.stringify(toolResult).slice(0, 500)}`
              );
              appendFileSync(
                'deepseek.log',
                `\nTool result:${JSON.stringify(toolResult).slice(0, 500)}`
              );
              // Add tool result to messages
              messages.push({
                role: 'tool',
                tool_call_id: toolCall.id,
                content: JSON.stringify(toolResult),
              });
            } catch (error) {
              console.error(`Tool execution error:`, error);
              appendFileSync('deepseek.log', `\nTool execution error:${error}`);
              // Add error message as tool result
              messages.push({
                role: 'tool',
                tool_call_id: toolCall.id,
                content: JSON.stringify({
                  error: error instanceof Error ? error.message : String(error),
                }),
              });
            }
          }

          // Continue loop to send tool results back to model
          continue;
        }

        // No more tool calls, return final response
        finalResponse = message?.content || '';
        break;
      }

      if (iteration >= this.maxIterations) {
        console.warn(`Reached maximum iterations (${this.maxIterations})`);
        appendFileSync(
          'deepseek.log',
          `\nReached maximum iterations (${this.maxIterations})`
        );
        if (!finalResponse) {
          finalResponse =
            'I apologize, but I reached the maximum number of iterations while processing your request. Please try breaking down your question into smaller parts.';
        }
      }

      return finalResponse;
    } catch (error) {
      this.handleError(error, 'DeepseekService.generate');
    }
  }
```


# äº”ã€æœ€å
åœ¨æ‰§è¡Œè¿™ä¸ªæœç´¢ä»£ç†çš„æ—¶å€™ï¼Œæˆ‘æ›´æ¢äº†ä¸åŒçš„æ¨¡å¼è¿›è¡Œæµ‹è¯•ï¼Œå¹¶ä¸”æ‰“å°å‡ºæ¥äº†æœç´¢ç­–ç•¥ï¼Œæˆ‘æœ‰ä¸€äº›å‘ç°å¯ä»¥åˆ†äº«ç»™å¤§å®¶
æˆ‘ç®€å•æµ‹è¯•äº†è¿™å‡ ç§æ¨¡å‹ï¼šDeepSeekV3.2ã€Qwen3ã€Glm-4.6ã€Gemini-2.5Proã€Gemini-2.5flashã€Claude-sonnet-4.5ã€GPT-5
æˆ‘å‘ç°è¡¨ç°æœ€å¥½çš„ç¡®å®æ˜¯ Claude å’Œ GPTï¼Œä½†æ˜¯é‡Œé¢æœ‰ä¸€äº›ç»†å¾®çš„å·®åˆ«ï¼Œæˆ‘çš„æ„Ÿè§‰æ˜¯
- Claude æœç´¢çš„ç­–ç•¥æ–¹å‘éå¸¸æ­£ç¡®ï¼Œè€Œä¸”å¯ä»¥æ„Ÿè§‰åˆ°æœ‰æ­¥éª¤çš„åœ¨æ‰§è¡Œï¼Œä¸ä¼šè¿‡åº¦çš„å»æ— è„‘çš„æœç´¢ï¼Œåƒæ˜¯ä¸€ä½éå¸¸èªæ˜çš„å‡ ä½•å›¾å½¢é—®é¢˜è®ºè¯å®¶ï¼Œè§£ä¸€æ­¥ï¼ŒéªŒè¯ä¸€æ­¥ï¼Œåœ¨æœç´¢ä¸€æ­¥ï¼Œå°±æ˜¯æ„Ÿè§‰ä¼˜é›…
- GPT çš„è¡¨ç°ä¹Ÿå¾ˆå¥½ï¼Œæˆ‘æ„Ÿè§‰åˆ°å®ƒçš„å°å¿ƒç¿¼ç¿¼ï¼Œæ˜¯å°å¿ƒç¿¼ç¿¼çš„ç¡®å®šæ–¹å‘ï¼Œä¸€æ—¦æ–¹å‘ç¡®å®šå°±ä¼šå¤§èƒ†çš„æ¢ç´¢ï¼Œåƒæ˜¯ä¸€ä½ç¨³é‡æˆç†Ÿçš„æ¢é™©å®¶ï¼Œæœ‰è°¨æ…åˆæœ‰å¼ºå¤§çš„æ‰§è¡ŒåŠ›